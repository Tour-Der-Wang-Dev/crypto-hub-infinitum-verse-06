
import { toast } from "@/components/ui/use-toast";

// Interface for vulnerability results
export interface Vulnerability {
  id: string;
  title: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  packageName?: string;
  description?: string;
  fixedIn?: string;
}

// Interface for scan results
export interface ScanResult {
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  timestamp: string;
}

/**
 * Scan for frontend vulnerabilities using Snyk API
 * Note: Requires a Snyk API key to be configured
 * @param packageJson The package.json content to scan
 * @returns Promise with scan results
 */
export const scanForVulnerabilities = async (packageJson: string): Promise<ScanResult> => {
  try {
    // This is a placeholder for the actual API call to Snyk
    // In a real implementation, you would use fetch or axios to call the Snyk API
    console.log('Scanning for vulnerabilities...');
    
    // Mock response for demonstration purposes
    // In production, replace this with an actual API call
    const mockResponse: ScanResult = {
      vulnerabilities: [
        {
          id: 'SNYK-JS-EXAMPLE-123456',
          title: 'Prototype Pollution',
          severity: 'high',
          packageName: 'example-package',
          description: 'This is a demonstration vulnerability',
          fixedIn: '1.2.3',
        },
      ],
      summary: {
        total: 1,
        critical: 0,
        high: 1,
        medium: 0,
        low: 0,
      },
      timestamp: new Date().toISOString(),
    };
    
    // For demonstration, we'll use setTimeout to simulate an API call
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(mockResponse);
      }, 1500);
    });
  } catch (error) {
    console.error('Error scanning for vulnerabilities:', error);
    toast({
      title: "Vulnerability Scan Failed",
      description: "Could not complete the security scan. Please try again later.",
      variant: "destructive",
    });
    
    // Return empty result on error
    return {
      vulnerabilities: [],
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
      },
      timestamp: new Date().toISOString(),
    };
  }
};

/**
 * Custom hook for vulnerability scanning
 * @returns Functions to start a scan and the current scan results
 */
export const useVulnerabilityScanner = () => {
  const [scanning, setScanning] = React.useState(false);
  const [results, setResults] = React.useState<ScanResult | null>(null);
  
  const startScan = async () => {
    setScanning(true);
    try {
      // In a real application, you would get the package.json content
      // For demo purposes, we'll use a placeholder
      const packageJson = JSON.stringify({
        dependencies: {
          "react": "18.3.1",
          "example-package": "1.0.0"
        }
      });
      
      const scanResults = await scanForVulnerabilities(packageJson);
      setResults(scanResults);
      
      if (scanResults.summary.total > 0) {
        toast({
          title: "Vulnerabilities Detected",
          description: `Found ${scanResults.summary.total} vulnerabilities in dependencies.`,
          variant: "destructive",
        });
      } else {
        toast({
          title: "No Vulnerabilities Detected",
          description: "Your application dependencies are secure.",
          variant: "default",
        });
      }
    } catch (error) {
      console.error('Error in vulnerability scan:', error);
    } finally {
      setScanning(false);
    }
  };
  
  return {
    scanning,
    results,
    startScan
  };
};
